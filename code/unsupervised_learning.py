# -*- coding: utf-8 -*-
#This document was generated by Pia Wolffram. 
#However, other sources have been used.
#These sources are written below and indicated at the specific places.

#Sources:
#Gis-Stack Exchange (2017): Questions (https://gis.stackexchange.com/questions/223910/using-rasterio-or-gdal-to-stack-multiple-bands-without-using-subprocess-commands)
#Iyer, N.(2021): Segment Satellite Images using Rasterio and Scikit-Learn (https://towardsdatascience.com/segment-satellite-images-using-rasterio-and-scikit-learn-fc048f465874)
#Kaplan, D. (2022): K-Means Accuracy Python With Silhouette Method (https://enjoymachinelearning.com/blog/k-means-accuracy-python-silhouette/#:~:text=than%20K%2DMeans.-,How%20Do%20You%20Measure%20Accuracy%20in%20K%20Means%20in%20Python,the%20distance%20to%20each%20point.)
#PyShark (2023): Calinski-Harabasz Index for K-Means Clustering Evaluation using Python (https://pyshark.com/calinski-harabasz-index-for-k-means-clustering-evaluation-using-python/)
#Yellowbrick (2019): Elbow Method (https://www.scikit-yb.org/en/latest/api/cluster/elbow.html)

import os
from sklearn import cluster
from sklearn.cluster import KMeans
from rasterio.plot import reshape_as_image
import rasterio
import matplotlib.pyplot as plt
import numpy as np
import sys
from yellowbrick.cluster import KElbowVisualizer
from sklearn.metrics import calinski_harabasz_score

#PREPROCESSING
#folder to training input files and predictions input files 
file_path = '../input_data/'
#this is the folder for the prediction files - they need to be added
file_path_pred = '/input_data/'

#Other source: Iyer, N.(2021)
#stack bands
def stack_bands(files, file_path):
  img_fp = 'sentinel_bands.tif'

  # Read metadata of first file
  with rasterio.open(file_path + files[0]) as src:
      meta = src.meta
  meta.update(count = len(files))

  # Read each layer and write it to stack
  with rasterio.open(img_fp, 'w', **meta) as dst:
      for id, layer in enumerate(files, start=1):
          with rasterio.open(file_path + layer) as srclassifer:
              dst.write_band(id, srclassifer.read(1))
  return img_fp

def get_files(file_path):
  files = os.listdir(file_path)
  return files

#Other Sources: Gis-Stack Exchange (2017)
#Write the result-array to a georeferenced image
def write_img_to_file(stacked_img, labelled_raster, img_raster, name, k):
  rast_img = rasterio.open(stacked_img)
  with rasterio.Env():
     profile = rast_img.profile
     profile.update(dtype=rasterio.uint8,count=1,compress='lzw')
     with rasterio.open('{}_{}.tif'.format(name,str(k)), 'w', **profile) as dst:
         img_cl = labelled_raster.reshape(img_raster.shape)
         dst.write(img_cl.astype(rasterio.uint8), 1)
  print("tif-image for k = {} written to folder!".format(str(k)))

###################################################

#TRAINING AND FINDING K
#Other sources: Iyer, N. (2021)
#train kmeans algorithm on given k
def train(k, file_path):

  # get the input files, stack them into one tif-file, opens the raster-file as an opened dataset object
  files = get_files(file_path)
  stacked_img = stack_bands(files, file_path)
  img_raster = rasterio.open(stacked_img)

  # create an empty array with same dimension and data type
  imgxyb = np.empty((img_raster.height, img_raster.width, img_raster.count), img_raster.meta['dtype'])

  # loop through the raster's bands to fill the empty array (shape[2] delivers the number of bands)
  for band in range(imgxyb.shape[2]):
      imgxyb[:,:,band] = img_raster.read(band+1)
  
  # convert to 1d array.
  img1d = imgxyb[:,:,:imgxyb.shape[2]].reshape((imgxyb.shape[0]*imgxyb.shape[1],imgxyb.shape[2]))

  # create an object of the classifier and train it
  model = KMeans(n_clusters=k)
  model.fit(img1d)

  # get the labels of the classes and reshape it x-y-bands shape order (one band only)
  labels = model.labels_
  values = set(labels)
  labelled_raster = labels.reshape(img_raster.shape)

  # Show the resulting raster and save it as jpg image
  plt.figure()
  plt.imshow(labelled_raster, cmap='viridis')
  plt.axis('off')
  plt.imsave('kMeans_train_image.jpg', labelled_raster, cmap='Accent')
  plt.show()

  #Write the result-array to a georeferenced image - source: Pia Wolffram 
  write_img_to_file(stacked_img, labelled_raster, img_raster, "kMeans", k)

  return model, img1d, labelled_raster

#Other sources: PyShark (2023), Kaplan, D. (2022)
# training method with several clusters
def find_k(number_of_clusters, file_path):
  print("Starting finding the optimal k!")

  inertia, chs = {}, {}
  for i in number_of_clusters:
    print("Calculating inertia and Calinski-Harabasz index for k =", i)
    model, img1d, labelled_raster = train(i, file_path)

    #calculate inertia and harabasz-score (for ch-score, i must be greater than 1)
    inertia.update({i: model.inertia_})
    pred = model.fit_predict(img1d)
    if(i>1):
      db_index = calinski_harabasz_score(img1d, pred)
      chs.update({i: db_index})

  return inertia, chs

# Evaluating diffrent k on the K-Means-Model
number_of_clusters = range(1,13)
inertia, chs = find_k(number_of_clusters, file_path)

#Plotting results of calinski-harabasz index
plt.plot(list(chs.keys()), list(chs.values()))
plt.xticks(np.arange(1,13, 1.0))
plt.title('The Calinski-Harabasz Index')
plt.xlabel("k")
plt.ylabel("Calinski-Harabasz Index")
plt.savefig("calinski_h.png")
plt.show()

#Plotting results of elbow method
plt.plot(list(inertia.keys()), list(inertia.values()), 'o-r')
plt.xticks(np.arange(1, 13, 1.0))
plt.title('The Elbow Method')
plt.xlabel('k')
plt.ylabel('Inertia')
plt.savefig("elbow_method.png")
plt.show()

###################################################################################

#TRAIN WITH FINAL K
number_of_clusters = 5
model, img1d, labelled_raster = train(number_of_clusters, file_path)

#Source: Yellowbrick (2019)
#Visulisation of Elbow Method, 
#metrics = {'silhouette', 'distortion', 'calinski_harabasz'
m = 'distortion'
visualizer = KElbowVisualizer(model, k=(1,13), metric=m, timings=False)
visualizer.fit(img1d)
visualizer.show(outpath="kelbow_{}.png".format(m))

###################################################

#PREDICTIONS
#Source: Iyer, N.(2021)
#predict using new k means method
def predict(model, img_fp):

  #img_fp is the stacked image, ird = image raster dataset
  ird = rasterio.open(img_fp)

  # create an empty array with same dimensions and data type 
  ird_xyb = np.empty((ird.height, ird.width,ird.count), ird.meta['dtype'])

  # loop through the raster bands and fill the empty array in x-y-bands order
  for band in range(ird_xyb.shape[2]):
      ird_xyb[:,:,band] = ird.read(band+1)

  # convert to 1d array
  ird_1d = ird_xyb[:,:,:ird_xyb.shape[2]].reshape(ird_xyb.shape[0]*ird_xyb.shape[1], ird_xyb.shape[2])

  # predict the clusters in the image 
  pred = model.predict(ird_1d)

  # reshape the 1d array predictions to x-y-bands shape order (only one band)
  img_pred = pred
  img_pred = img_pred.reshape(ird_xyb[:,:,0].shape)

  return img_pred

def prediction(file_path_pred, model):

  #get files and stack bands 
  files = get_files(file_path_pred)
  img_fp = stack_bands(files, file_path_pred)

  # predict on trained model and save to image
  kmeans_predictions = predict(model, img_fp)
  plt.imsave('kmeans_pred_image_' + files[0] + '.jpg', kmeans_predictions, cmap='Accent')

  #Show the resulting array and save it as jpg image
  plt.figure()
  plt.imshow(kmeans_predictions, cmap='viridis')
  plt.axis('off')
  plt.imsave('kMeans_prediction_image.jpg', labelled_raster, cmap='viridis')
  plt.show()

  return

prediction(file_path_pred, model)

